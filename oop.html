<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=0,viewport-fit=cover">
  <meta name="renderer" content="webkit">
  <meta name="keywords" content="">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
  <meta http-equiv="x-dns-prefetch-control" content="on">
  <title>最优的原型继承</title>
</head>

<body>
  <script>
    /**
     * 借助构造函数实现继承
     * 缺点：不会继承原型上的属性
    */
    function Person1() {
      this.name = 'person';
      this.arr = [1, 2, 3];
    }

    // 不会继承原型上的属性
    Person1.prototype.say = function () {
      console.log('说话');
    }

    function Child1() {
      Person1.call(this); // 或者apply
      this.age = 20;
    }
    console.log(new Child1);

    /**
     * 使用原型链继承
     * 缺点：修改一个实例的属性，会影响另外实例的属性
     */
    function Person2() {
      this.name = 'person2';
      this.arr = [1, 2, 3];
    }
    function Child2() {
      this.age = '21'
    }
    Child2.prototype = new Person2();

    // 修改一个实例的属性，会影响另外实例的属性
    var s1 = new Child2().arr;
    var s2 = new Child2().arr;

    s1.push(4);

    console.log(s1);
    console.log(s2);

    /**
     * 组合继承
     */
    function Person3() {
      this.name = 'person3';
      this.arr = [1, 2, 3];
    }
    function Child3() {
      Person3.call(this);
      this.age = '21'
    }
    Child3.prototype = new Person3;

    /**
     * 组合继承优化
     * 缺点：无法识别子原型的 constructor
     */
    function Person4() {
      this.name = 'person3';
      this.arr = [1, 2, 3];
    }
    function Child4() {
      Person4.call(this);
      this.age = '21'
    }
    Child4.prototype = Person4.prototype;

    /**
     * 组合继承优化2
     */
    function Person5() {
      this.name = 'prototype'
      this.arr = [1,2,3]
    }

    function Child5() {
      Person5.call(this)
      this.age = 23
    }

    Child5.prototype = Object.create(Person5.prototype)
    Child5.prototype.constructor = Child5

    var child5 = new Child5()
    console.log(child5)
    


    // 这道题主要考核的是对原型链继承这块的理解
    // function Parent() {
    //   this.a = 1;
    //   this.b = [1, 2, this.a];
    //   this.c = { demo: 5 };
    //   this.show = function () {
    //     console.log(this.a + '' + this.c.demo + ':' + this.b)
    //   }
    // }

    // function Child() {
    //   this.a = 2;
    //   this.change = function () {
    //     this.b.push(this.a);
    //     this.a = this.b.length;
    //     this.c.demo = this.a++;
    //   }
    // }

    // Child.prototype = new Parent();
    // var parent = new Parent();
    // var child1 = new Child();
    // var child2 = new Child();

    // console.log(child1.show);

    // child1.a = 11;
    // child2.a = 12;

    // // 这前面几个还算简单,继续看下去
    // parent.show(); // 15:1,2,1

    // // 因为 Child 自身没有 show 的方法,所以往原型链的上游找;
    // // 找到父类的,this 因为没更改,所以输出结果如下
    // child1.show(); // 115:1,2,1
    // child2.show(); // 125:1,2,1

    // child1.change();  // 改变一些数据,没有输出  child.b = [1,2,this.a,11,12]; child.a = 5; this.c.demo = 5
    // child2.change();  // +1  child.b = [1,2,this.a,11,12]; child.a = 6; this.c.demo = 5

    // parent.show(); // 15:1,2,1

    // child1.show(); // 55:1,2,1,11,12
    // child2.show(); // 65:1,2,1,11,12
  </script>
</body>

</html>